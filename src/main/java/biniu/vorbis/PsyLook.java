/*
 * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.
 * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS
 * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE
 * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.
 *
 * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2002
 * by the XIPHOPHORUS Company http://www.xiph.org/
 */

package biniu.vorbis;

/**
 * EncoderVorbis</p>
 * <p>Description: Codec for encoding music files (wav -> ogg) </p>
 * @author Zbigniew Sudnik
 * @version 1.1.0j 2005-05-01 07:00:00
 */
class PsyLook {

    // more detailed ATH; the bass if flat to save stressing the floor
    // overly for only a bin or two of savings.

    static int MAX_ATH = 88;
    static float[] ATH = {
            /* 15 */  -51, -52, -53, -54, -55, -56, -57, -58,
            /* 31 */  -59, -60, -61, -62, -63, -64, -65, -66,
            /* 63 */  -67, -68, -69, -70, -71, -72, -73, -74,
            /* 125 */ -75, -76, -77, -78, -80, -81, -82, -83,
            /* 250 */ -84, -85, -86, -87, -88, -88, -89, -89,
            /* 500 */ -90, -91, -91, -92, -93, -94, -95, -96,
            /* 1k */  -96, -97, -98, -98, -99, -99, -100, -100,
            /* 2k */ -101, -102, -103, -104, -106, -107, -107, -107,
            /* 4k */ -107, -105, -103, -102, -101, -99, -98, -96,
            /* 8k */  -95, -95, -96, -97, -96, -95, -93, -90,
            /* 16k */ -80, -70, -50, -40, -30, -30, -30, -30
    };

    // The tone masking curves from Ehmer's and Fielder's papers have been
    // replaced by an empirically collected data set.  The previously
    // published values were, far too often, simply on crack. */

    private static final int EHMER_MAX = 56;
    private static final int EHMER_OFFSET = 16;

    // masking tones from -50 to 0dB, 62.5 through 16kHz at half octaves
    // test tones from -2 octaves to +5 octaves sampled at eighth octaves */
    // (Vorbis 0dB, the loudest possible tone, is assumed to be ~100dB SPL
    // for collection of these curves)

//static float tonemasks[P_BANDS][6][EHMER_MAX]={
    private static final float[][][] tonemasks = {
            // 62.5 Hz
            {{-60, -60, -60, -60, -60, -60, -60, -60,
                    -60, -60, -60, -60, -62, -62, -65, -73,
                    -69, -68, -68, -67, -70, -70, -72, -74,
                    -75, -79, -79, -80, -83, -88, -93, -100,
                    -110, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-48, -48, -48, -48, -48, -48, -48, -48,
                            -48, -48, -48, -48, -48, -53, -61, -66,
                            -66, -68, -67, -70, -76, -76, -72, -73,
                            -75, -76, -78, -79, -83, -88, -93, -100,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-37, -37, -37, -37, -37, -37, -37, -37,
                            -38, -40, -42, -46, -48, -53, -55, -62,
                            -65, -58, -56, -56, -61, -60, -65, -67,
                            -69, -71, -77, -77, -78, -80, -82, -84,
                            -88, -93, -98, -106, -112, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-25, -25, -25, -25, -25, -25, -25, -25,
                            -25, -26, -27, -29, -32, -38, -48, -52,
                            -52, -50, -48, -48, -51, -52, -54, -60,
                            -67, -67, -66, -68, -69, -73, -73, -76,
                            -80, -81, -81, -85, -85, -86, -88, -93,
                            -100, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-16, -16, -16, -16, -16, -16, -16, -16,
                            -17, -19, -20, -22, -26, -28, -31, -40,
                            -47, -39, -39, -40, -42, -43, -47, -51,
                            -57, -52, -55, -55, -60, -58, -62, -63,
                            -70, -67, -69, -72, -73, -77, -80, -82,
                            -83, -87, -90, -94, -98, -104, -115, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-8, -8, -8, -8, -8, -8, -8, -8,
                            -8, -8, -10, -11, -15, -19, -25, -30,
                            -34, -31, -30, -31, -29, -32, -35, -42,
                            -48, -42, -44, -46, -50, -50, -51, -52,
                            -59, -54, -55, -55, -58, -62, -63, -66,
                            -72, -73, -76, -75, -78, -80, -80, -81,
                            -84, -88, -90, -94, -98, -101, -106, -110}},
            // 88Hz
            {{-66, -66, -66, -66, -66, -66, -66, -66,
                    -66, -66, -66, -66, -66, -67, -67, -67,
                    -76, -72, -71, -74, -76, -76, -75, -78,
                    -79, -79, -81, -83, -86, -89, -93, -97,
                    -100, -105, -110, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-47, -47, -47, -47, -47, -47, -47, -47,
                            -47, -47, -47, -48, -51, -55, -59, -66,
                            -66, -66, -67, -66, -68, -69, -70, -74,
                            -79, -77, -77, -78, -80, -81, -82, -84,
                            -86, -88, -91, -95, -100, -108, -116, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-36, -36, -36, -36, -36, -36, -36, -36,
                            -36, -37, -37, -41, -44, -48, -51, -58,
                            -62, -60, -57, -59, -59, -60, -63, -65,
                            -72, -71, -70, -72, -74, -77, -76, -78,
                            -81, -81, -80, -83, -86, -91, -96, -100,
                            -105, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-28, -28, -28, -28, -28, -28, -28, -28,
                            -28, -30, -32, -32, -33, -35, -41, -49,
                            -50, -49, -47, -48, -48, -52, -51, -57,
                            -65, -61, -59, -61, -64, -69, -70, -74,
                            -77, -77, -78, -81, -84, -85, -87, -90,
                            -92, -96, -100, -107, -112, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-19, -19, -19, -19, -19, -19, -19, -19,
                            -20, -21, -23, -27, -30, -35, -36, -41,
                            -46, -44, -42, -40, -41, -41, -43, -48,
                            -55, -53, -52, -53, -56, -59, -58, -60,
                            -67, -66, -69, -71, -72, -75, -79, -81,
                            -84, -87, -90, -93, -97, -101, -107, -114,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-9, -9, -9, -9, -9, -9, -9, -9,
                            -11, -12, -12, -15, -16, -20, -23, -30,
                            -37, -34, -33, -34, -31, -32, -32, -38,
                            -47, -44, -41, -40, -47, -49, -46, -46,
                            -58, -50, -50, -54, -58, -62, -64, -67,
                            -67, -70, -72, -76, -79, -83, -87, -91,
                            -96, -100, -104, -110, -999, -999, -999, -999}},
            // 125 Hz
            {{-62, -62, -62, -62, -62, -62, -62, -62,
                    -62, -62, -63, -64, -66, -67, -66, -68,
                    -75, -72, -76, -75, -76, -78, -79, -82,
                    -84, -85, -90, -94, -101, -110, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-59, -59, -59, -59, -59, -59, -59, -59,
                            -59, -59, -59, -60, -60, -61, -63, -66,
                            -71, -68, -70, -70, -71, -72, -72, -75,
                            -81, -78, -79, -82, -83, -86, -90, -97,
                            -103, -113, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-53, -53, -53, -53, -53, -53, -53, -53,
                            -53, -54, -55, -57, -56, -57, -55, -61,
                            -65, -60, -60, -62, -63, -63, -66, -68,
                            -74, -73, -75, -75, -78, -80, -80, -82,
                            -85, -90, -96, -101, -108, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-46, -46, -46, -46, -46, -46, -46, -46,
                            -46, -46, -47, -47, -47, -47, -48, -51,
                            -57, -51, -49, -50, -51, -53, -54, -59,
                            -66, -60, -62, -67, -67, -70, -72, -75,
                            -76, -78, -81, -85, -88, -94, -97, -104,
                            -112, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-36, -36, -36, -36, -36, -36, -36, -36,
                            -39, -41, -42, -42, -39, -38, -41, -43,
                            -52, -44, -40, -39, -37, -37, -40, -47,
                            -54, -50, -48, -50, -55, -61, -59, -62,
                            -66, -66, -66, -69, -69, -73, -74, -74,
                            -75, -77, -79, -82, -87, -91, -95, -100,
                            -108, -115, -999, -999, -999, -999, -999, -999},
                    {-28, -26, -24, -22, -20, -20, -23, -29,
                            -30, -31, -28, -27, -28, -28, -28, -35,
                            -40, -33, -32, -29, -30, -30, -30, -37,
                            -45, -41, -37, -38, -45, -47, -47, -48,
                            -53, -49, -48, -50, -49, -49, -51, -52,
                            -58, -56, -57, -56, -60, -61, -62, -70,
                            -72, -74, -78, -83, -88, -93, -100, -106}},
            // 177 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -110, -105, -100, -95, -91, -87, -83,
                    -80, -78, -76, -78, -78, -81, -83, -85,
                    -86, -85, -86, -87, -90, -97, -107, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -110, -105, -100, -95, -90,
                            -85, -81, -77, -73, -70, -67, -67, -68,
                            -75, -73, -70, -69, -70, -72, -75, -79,
                            -84, -83, -84, -86, -88, -89, -89, -93,
                            -98, -105, -112, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-105, -100, -95, -90, -85, -80, -76, -71,
                            -68, -68, -65, -63, -63, -62, -62, -64,
                            -65, -64, -61, -62, -63, -64, -66, -68,
                            -73, -73, -74, -75, -76, -81, -83, -85,
                            -88, -89, -92, -95, -100, -108, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-80, -75, -71, -68, -65, -63, -62, -61,
                            -61, -61, -61, -59, -56, -57, -53, -50,
                            -58, -52, -50, -50, -52, -53, -54, -58,
                            -67, -63, -67, -68, -72, -75, -78, -80,
                            -81, -81, -82, -85, -89, -90, -93, -97,
                            -101, -107, -114, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-65, -61, -59, -57, -56, -55, -55, -56,
                            -56, -57, -55, -53, -52, -47, -44, -44,
                            -50, -44, -41, -39, -39, -42, -40, -46,
                            -51, -49, -50, -53, -54, -63, -60, -61,
                            -62, -66, -66, -66, -70, -73, -74, -75,
                            -76, -75, -79, -85, -89, -91, -96, -102,
                            -110, -999, -999, -999, -999, -999, -999, -999},
                    {-52, -50, -49, -49, -48, -48, -48, -49,
                            -50, -50, -49, -46, -43, -39, -35, -33,
                            -38, -36, -32, -29, -32, -32, -32, -35,
                            -44, -39, -38, -38, -46, -50, -45, -46,
                            -53, -50, -50, -50, -54, -54, -53, -53,
                            -56, -57, -59, -66, -70, -72, -74, -79,
                            -83, -85, -90, -97, -114, -999, -999, -999}},
            // 250 Hz
            {{-999, -999, -999, -999, -999, -999, -110, -105,
                    -100, -95, -90, -86, -80, -75, -75, -79,
                    -80, -79, -80, -81, -82, -88, -95, -103,
                    -110, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -108, -103, -98, -93,
                            -88, -83, -79, -78, -75, -71, -67, -68,
                            -73, -73, -72, -73, -75, -77, -80, -82,
                            -88, -93, -100, -107, -114, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -110, -105, -101, -96, -90,
                            -86, -81, -77, -73, -69, -66, -61, -62,
                            -66, -64, -62, -65, -66, -70, -72, -76,
                            -81, -80, -84, -90, -95, -102, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -107, -103, -97, -92, -88,
                            -83, -79, -74, -70, -66, -59, -53, -58,
                            -62, -55, -54, -54, -54, -58, -61, -62,
                            -72, -70, -72, -75, -78, -80, -81, -80,
                            -83, -83, -88, -93, -100, -107, -115, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -105, -100, -95, -90, -85,
                            -80, -75, -70, -66, -62, -56, -48, -44,
                            -48, -46, -46, -43, -46, -48, -48, -51,
                            -58, -58, -59, -60, -62, -62, -61, -61,
                            -65, -64, -65, -68, -70, -74, -75, -78,
                            -81, -86, -95, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -105, -100, -95, -90, -85, -80,
                            -75, -70, -65, -61, -55, -49, -39, -33,
                            -40, -35, -32, -38, -40, -33, -35, -37,
                            -46, -41, -45, -44, -46, -42, -45, -46,
                            -52, -50, -50, -50, -54, -54, -55, -57,
                            -62, -64, -66, -68, -70, -76, -81, -90,
                            -100, -110, -999, -999, -999, -999, -999, -999}},
            // 354 hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -105, -98, -90, -85, -82, -83, -80, -78,
                    -84, -79, -80, -83, -87, -89, -91, -93,
                    -99, -106, -117, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -98, -90, -85, -80, -75, -70, -68,
                            -74, -72, -74, -77, -80, -82, -85, -87,
                            -92, -89, -91, -95, -100, -106, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -98, -90, -83, -75, -71, -63, -64,
                            -67, -62, -64, -67, -70, -73, -77, -81,
                            -84, -83, -85, -89, -90, -93, -98, -104,
                            -109, -114, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -103, -96, -88, -81, -75, -68, -58, -54,
                            -56, -54, -56, -56, -58, -60, -63, -66,
                            -74, -69, -72, -72, -75, -74, -77, -81,
                            -81, -82, -84, -87, -93, -96, -99, -104,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -108, -102, -96,
                            -91, -85, -80, -74, -68, -60, -51, -46,
                            -48, -46, -43, -45, -47, -47, -49, -48,
                            -56, -53, -55, -58, -57, -63, -58, -60,
                            -66, -64, -67, -70, -70, -74, -77, -84,
                            -86, -89, -91, -93, -94, -101, -109, -118,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -108, -103, -98, -93, -88,
                            -83, -78, -73, -68, -60, -53, -44, -35,
                            -38, -38, -34, -34, -36, -40, -41, -44,
                            -51, -45, -46, -47, -46, -54, -50, -49,
                            -50, -50, -50, -51, -54, -57, -58, -60,
                            -66, -66, -66, -64, -65, -68, -77, -82,
                            -87, -95, -110, -999, -999, -999, -999, -999}},
            // 500 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -107, -102, -97, -92, -87, -83, -78, -75,
                    -82, -79, -83, -85, -89, -92, -95, -98,
                    -101, -105, -109, -113, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -106,
                            -100, -95, -90, -86, -81, -78, -74, -69,
                            -74, -74, -76, -79, -83, -84, -86, -89,
                            -92, -97, -93, -100, -103, -107, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -100,
                            -95, -90, -87, -83, -80, -75, -69, -60,
                            -66, -66, -68, -70, -74, -78, -79, -81,
                            -81, -83, -84, -87, -93, -96, -99, -103,
                            -107, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -108, -103, -98,
                            -93, -89, -85, -82, -78, -71, -62, -55,
                            -58, -58, -54, -54, -55, -59, -61, -62,
                            -70, -66, -66, -67, -70, -72, -75, -78,
                            -84, -84, -84, -88, -91, -90, -95, -98,
                            -102, -103, -106, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -108, -103, -98, -94,
                            -90, -87, -82, -79, -73, -67, -58, -47,
                            -50, -45, -41, -45, -48, -44, -44, -49,
                            -54, -51, -48, -47, -49, -50, -51, -57,
                            -58, -60, -63, -69, -70, -69, -71, -74,
                            -78, -82, -90, -95, -101, -105, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -105, -101, -97, -93, -90,
                            -85, -80, -77, -72, -65, -56, -48, -37,
                            -40, -36, -34, -40, -50, -47, -38, -41,
                            -47, -38, -35, -39, -38, -43, -40, -45,
                            -50, -45, -44, -47, -50, -55, -48, -48,
                            -52, -66, -70, -76, -82, -90, -97, -105,
                            -110, -999, -999, -999, -999, -999, -999, -999}},
            // 707 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -108, -103, -98, -93, -86, -79, -76,
                    -83, -81, -85, -87, -89, -93, -98, -102,
                    -107, -112, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -108, -103, -98, -93, -86, -79, -71,
                            -77, -74, -77, -79, -81, -84, -85, -90,
                            -92, -93, -92, -98, -101, -108, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -108, -103, -98, -93, -87, -78, -68, -65,
                            -66, -62, -65, -67, -70, -73, -75, -78,
                            -82, -82, -83, -84, -91, -93, -98, -102,
                            -106, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -105, -100, -95, -90, -82, -74, -62, -57,
                            -58, -56, -51, -52, -52, -54, -54, -58,
                            -66, -59, -60, -63, -66, -69, -73, -79,
                            -83, -84, -80, -81, -81, -82, -88, -92,
                            -98, -105, -113, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -102, -97, -92, -84, -79, -69, -57, -47,
                            -52, -47, -44, -45, -50, -52, -42, -42,
                            -53, -43, -43, -48, -51, -56, -55, -52,
                            -57, -59, -61, -62, -67, -71, -78, -83,
                            -86, -94, -98, -103, -110, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -105, -100,
                            -95, -90, -84, -78, -70, -61, -51, -41,
                            -40, -38, -40, -46, -52, -51, -41, -40,
                            -46, -40, -38, -38, -41, -46, -41, -46,
                            -47, -43, -43, -45, -41, -45, -56, -67,
                            -68, -83, -87, -90, -95, -102, -107, -113,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 1000 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -109, -105, -101, -96, -91, -84, -77,
                    -82, -82, -85, -89, -94, -100, -106, -110,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -106, -103, -98, -92, -85, -80, -71,
                            -75, -72, -76, -80, -84, -86, -89, -93,
                            -100, -107, -113, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -104, -101, -97, -92, -88, -84, -80, -64,
                            -66, -63, -64, -66, -69, -73, -77, -83,
                            -83, -86, -91, -98, -104, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -107,
                            -104, -101, -97, -92, -90, -84, -74, -57,
                            -58, -52, -55, -54, -50, -52, -50, -52,
                            -63, -62, -69, -76, -77, -78, -78, -79,
                            -82, -88, -94, -100, -106, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -102,
                            -98, -95, -90, -85, -83, -78, -70, -50,
                            -50, -41, -44, -49, -47, -50, -50, -44,
                            -55, -46, -47, -48, -48, -54, -49, -49,
                            -58, -62, -71, -81, -87, -92, -97, -102,
                            -108, -114, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -106, -102,
                            -98, -95, -90, -85, -83, -78, -70, -45,
                            -43, -41, -47, -50, -51, -50, -49, -45,
                            -47, -41, -44, -41, -39, -43, -38, -37,
                            -40, -41, -44, -50, -58, -65, -73, -79,
                            -85, -92, -97, -101, -105, -109, -113, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 1414 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -107, -100, -95, -87, -81,
                    -85, -83, -88, -93, -100, -107, -114, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -107, -101, -95, -88, -83, -76,
                            -73, -72, -79, -84, -90, -95, -100, -105,
                            -110, -115, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -104, -98, -92, -87, -81, -70,
                            -65, -62, -67, -71, -74, -80, -85, -91,
                            -95, -99, -103, -108, -111, -114, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -103, -97, -90, -85, -76, -60,
                            -56, -54, -60, -62, -61, -56, -63, -65,
                            -73, -74, -77, -75, -78, -81, -86, -87,
                            -88, -91, -94, -98, -103, -110, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -105,
                            -100, -97, -92, -86, -81, -79, -70, -57,
                            -51, -47, -51, -58, -60, -56, -53, -50,
                            -58, -52, -50, -50, -53, -55, -64, -69,
                            -71, -85, -82, -78, -81, -85, -95, -102,
                            -112, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -105,
                            -100, -97, -92, -85, -83, -79, -72, -49,
                            -40, -43, -43, -54, -56, -51, -50, -40,
                            -43, -38, -36, -35, -37, -38, -37, -44,
                            -54, -60, -57, -60, -70, -75, -84, -92,
                            -103, -112, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 2000 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -110, -102, -95, -89, -82,
                    -83, -84, -90, -92, -99, -107, -113, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -107, -101, -95, -89, -83, -72,
                            -74, -78, -85, -88, -88, -90, -92, -98,
                            -105, -111, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -109, -103, -97, -93, -87, -81, -70,
                            -70, -67, -75, -73, -76, -79, -81, -83,
                            -88, -89, -97, -103, -110, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -107, -100, -94, -88, -83, -75, -63,
                            -59, -59, -63, -66, -60, -62, -67, -67,
                            -77, -76, -81, -88, -86, -92, -96, -102,
                            -109, -116, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -105, -98, -92, -86, -81, -73, -56,
                            -52, -47, -55, -60, -58, -52, -51, -45,
                            -49, -50, -53, -54, -61, -71, -70, -69,
                            -78, -79, -87, -90, -96, -104, -112, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -103, -96, -90, -86, -78, -70, -51,
                            -42, -47, -48, -55, -54, -54, -53, -42,
                            -35, -28, -33, -38, -37, -44, -47, -49,
                            -54, -63, -68, -78, -82, -89, -94, -99,
                            -104, -109, -114, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 2828 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -110, -100, -90, -79,
                    -85, -81, -82, -82, -89, -94, -99, -103,
                    -109, -115, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -105, -97, -85, -72,
                            -74, -70, -70, -70, -76, -85, -91, -93,
                            -97, -103, -109, -115, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -112, -93, -81, -68,
                            -62, -60, -60, -57, -63, -70, -77, -82,
                            -90, -93, -98, -104, -109, -113, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -113, -100, -93, -84, -63,
                            -58, -48, -53, -54, -52, -52, -57, -64,
                            -66, -76, -83, -81, -85, -85, -90, -95,
                            -98, -101, -103, -106, -108, -111, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -105, -95, -86, -74, -53,
                            -50, -38, -43, -49, -43, -42, -39, -39,
                            -46, -52, -57, -56, -72, -69, -74, -81,
                            -87, -92, -94, -97, -99, -102, -105, -108,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -108, -99, -90, -76, -66, -45,
                            -43, -41, -44, -47, -43, -47, -40, -30,
                            -31, -31, -39, -33, -40, -41, -43, -53,
                            -59, -70, -73, -77, -79, -82, -84, -87,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 4000 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -110, -91, -76,
                    -75, -85, -93, -98, -104, -110, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -91, -70,
                            -70, -75, -86, -89, -94, -98, -101, -106,
                            -110, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -60,
                            -65, -64, -74, -83, -88, -91, -95, -99,
                            -103, -107, -110, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -58,
                            -55, -49, -66, -68, -71, -78, -78, -80,
                            -88, -85, -89, -97, -100, -105, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -110, -95, -80, -53,
                            -52, -41, -59, -59, -49, -58, -56, -63,
                            -86, -79, -90, -93, -98, -103, -107, -112,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -97, -91, -73, -45,
                            -40, -33, -53, -61, -49, -54, -50, -50,
                            -60, -52, -67, -74, -81, -92, -96, -100,
                            -105, -110, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 5657 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -113, -106, -99, -92, -77,
                    -80, -88, -97, -106, -115, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -116, -109, -102, -95, -89, -74,
                            -72, -88, -87, -95, -102, -109, -116, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -116, -109, -102, -95, -89, -75,
                            -66, -74, -77, -78, -86, -87, -90, -96,
                            -105, -115, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -115, -108, -101, -94, -88, -66,
                            -56, -61, -70, -65, -78, -72, -83, -84,
                            -93, -98, -105, -110, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -110, -105, -95, -89, -82, -57,
                            -52, -52, -59, -56, -59, -58, -69, -67,
                            -88, -82, -82, -89, -94, -100, -108, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -110, -101, -96, -90, -83, -77, -54,
                            -43, -38, -50, -48, -52, -48, -42, -42,
                            -51, -52, -53, -59, -65, -71, -78, -85,
                            -95, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 8000 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -120, -105, -86, -68,
                    -78, -79, -90, -100, -110, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -120, -105, -86, -66,
                            -73, -77, -88, -96, -105, -115, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -120, -105, -92, -80, -61,
                            -64, -68, -80, -87, -92, -100, -110, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -120, -104, -91, -79, -52,
                            -60, -54, -64, -69, -77, -80, -82, -84,
                            -85, -87, -88, -90, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -118, -100, -87, -77, -49,
                            -50, -44, -58, -61, -61, -67, -65, -62,
                            -62, -62, -65, -68, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -115, -98, -84, -62, -49,
                            -44, -38, -46, -49, -49, -46, -39, -37,
                            -39, -40, -42, -43, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 11314 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -110, -88, -74,
                    -77, -82, -82, -85, -90, -94, -99, -104,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -88, -66,
                            -70, -81, -80, -81, -84, -88, -91, -93,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -88, -61,
                            -63, -70, -71, -74, -77, -80, -83, -85,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -110, -86, -62,
                            -63, -62, -62, -58, -52, -50, -50, -52,
                            -54, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -118, -108, -84, -53,
                            -50, -50, -50, -55, -47, -45, -40, -40,
                            -40, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -118, -100, -73, -43,
                            -37, -42, -43, -53, -38, -37, -35, -35,
                            -38, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}},
            // 16000 Hz
            {{-999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -110, -100, -91, -84, -74,
                    -80, -80, -80, -80, -80, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999,
                    -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -91, -84, -74,
                            -68, -68, -68, -68, -68, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -86, -78, -70,
                            -60, -45, -30, -21, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -87, -78, -67,
                            -48, -38, -29, -21, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -86, -69, -56,
                            -45, -35, -33, -29, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999},
                    {-999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -110, -100, -83, -71, -48,
                            -27, -38, -37, -34, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999,
                            -999, -999, -999, -999, -999, -999, -999, -999}}
    };

    int n;
    PsyInfo vi;

    float[][][] tonecurves;
    float[][] peakatt;
    float[][][] noisecurves;

    float[] ath;
    int[] octave;

    // psychoacoustic setup

    /** 62Hz to 16kHz */
    private static final int P_BANDS = 17;
    /** 30dB to 100dB */
    private static final int P_LEVELS = 8;
    /** 30 dB */
    private static final float P_LEVEL_0 = 30.f;
    private static final int P_NOISECURVES = 3;

    private static final int NOISE_COMPAND_LEVELS = 40;
    private static final float NEGINF = -9999.f;
    private int[] index;

//int n;

    //  float[][][] tonecurves;
    float[][] noiseoffset;

//float[] ath;
    /** in n.ocshift format */
//int[] octave;
    int[] bark;

    int firstoc;
    int shiftoc;
    /** power of two, please */
    int eighth_octave_lines;
    int total_octave_lines;
    /** cache it */
    long rate;

    /** Masking compensation value */
    float m_val;

    public void noiseMask(float[] logmdct, int plogmdct, float[] logmask) {

        int i, n = this.n;
        float[] work = new float[n];
        barkNoiseHybridmp(logmdct, plogmdct, logmask, 140.f, -1);

        for (i = 0; i < n; i++) work[i] = logmdct[i + plogmdct] - logmask[i];

        barkNoiseHybridmp(work, 0, logmask, 0.0f, this.vi.noisewindowfixed);

        for (i = 0; i < n; i++) work[i] = logmdct[i + plogmdct] - work[i];

        for (i = 0; i < n; i++) {
            int dB = (int) (logmask[i] + .5f);
            if (dB >= NOISE_COMPAND_LEVELS) dB = NOISE_COMPAND_LEVELS - 1;
            if (dB < 0) dB = 0;
            logmask[i] = work[i] + this.vi.noisecompand[dB];
        }
    }

    public void toneMask(float[] logfft,
                         float[] logmask,
                         float global_specmax,
                         float local_specmax) {

        int i, n = this.n;

        float[] seed = new float[this.total_octave_lines];
        float att = local_specmax + this.vi.ath_adjatt;
        for (i = 0; i < this.total_octave_lines; i++) seed[i] = NEGINF;

        // set the ATH (floating below localmax, not global max by a
        // specified att)
        if (att < this.vi.ath_maxatt) att = this.vi.ath_maxatt;

        for (i = 0; i < n; i++)
            logmask[i] = this.ath[i] + att;

        // tone masking
        seed_loop(this.tonecurves, logfft, logmask, seed, global_specmax);
        maxSeeds(seed, logmask);

    }

    /** bleaugh, this is more complicated than it needs to be */
    private void maxSeeds(float[] seed,
                          float[] flr) {
        int n = this.total_octave_lines;
        int linesper = this.eighth_octave_lines;
        int linpos = 0;
        int pos;

        seedChase(seed, linesper, n); // for masking

        pos = this.octave[0] - this.firstoc - (linesper >> 1);

        while (linpos + 1 < this.n) {
            float minV = seed[pos];
            long end = ((this.octave[linpos] + this.octave[linpos + 1]) >> 1) - this.firstoc;
            if (minV > this.vi.tone_abs_limit) minV = this.vi.tone_abs_limit;
            while (pos + 1 <= end) {
                pos++;
                if ((seed[pos] > NEGINF && seed[pos] < minV) || minV == NEGINF)
                    minV = seed[pos];
            }

            end = pos + this.firstoc;
            for (; linpos < this.n && this.octave[linpos] <= end; linpos++)
                if (flr[linpos] < minV) flr[linpos] = minV;
        }

        {
            float minV = seed[this.total_octave_lines - 1];
            for (; linpos < this.n; linpos++)
                if (flr[linpos] < minV) flr[linpos] = minV;
        }
    }

    private void barkNoiseHybridmp(float[] f,
                                   int pf,
                                   float[] noise,
                                   float offset,
                                   int fixed) {

        float[] N = new float[n];
        float[] X = new float[n];
        float[] XX = new float[n];
        float[] Y = new float[n];
        float[] XY = new float[n];

        float tN, tX, tXX, tY, tXY;
        int i;

        int lo, hi;
        float R, A = 0.0f, B = 0.0f, D = 0.0f;
        float w, x, y;

        tN = tX = tXX = tY = tXY = 0.f;

        y = f[pf] + offset;
        if (y < 1.f) y = 1.f;

        w = y * y * .5f;

        tN += w;
        tX += w;
        tY += w * y;

        N[0] = tN;
        X[0] = tX;
        XX[0] = tXX;
        Y[0] = tY;
        XY[0] = tXY;

        for (i = 1, x = 1.f; i < n; i++, x += 1.f) {

            y = f[i + pf] + offset;
            if (y < 1.f) y = 1.f;

            w = y * y;

            tN += w;
            tX += w * x;
            tXX += w * x * x;
            tY += w * y;
            tXY += w * x * y;

            N[i] = tN;
            X[i] = tX;
            XX[i] = tXX;
            Y[i] = tY;
            XY[i] = tXY;
        }

        for (i = 0, x = 0.f; ; i++, x += 1.f) {

            lo = this.bark[i] >> 16;
            if (lo >= 0) break;
            hi = this.bark[i] & 0xffff;

            tN = N[hi] + N[-lo];
            tX = X[hi] - X[-lo];
            tXX = XX[hi] + XX[-lo];
            tY = Y[hi] + Y[-lo];
            tXY = XY[hi] - XY[-lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;
            if (R < 0.f)
                R = 0.f;

            noise[i] = R - offset;
        }

        for (; ; i++, x += 1.f) {

            lo = this.bark[i] >> 16;
            hi = this.bark[i] & 0xffff;
            if (hi >= n) break;

            tN = N[hi] - N[lo];
            tX = X[hi] - X[lo];
            tXX = XX[hi] - XX[lo];
            tY = Y[hi] - Y[lo];
            tXY = XY[hi] - XY[lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;
            if (R < 0.f) R = 0.f;

            noise[i] = R - offset;
        }
        for (; i < n; i++, x += 1.f) {

            R = (A + x * B) / D;
            if (R < 0.f) R = 0.f;

            noise[i] = R - offset;
        }

        if (fixed <= 0) return;

        for (i = 0, x = 0.f; ; i++, x += 1.f) {
            hi = i + fixed / 2;
            lo = hi - fixed;
            if (lo >= 0) break;

            tN = N[hi] + N[-lo];
            tX = X[hi] - X[-lo];
            tXX = XX[hi] + XX[-lo];
            tY = Y[hi] + Y[-lo];
            tXY = XY[hi] - XY[-lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;

            if (R - offset < noise[i]) noise[i] = R - offset;
        }
        for (; ; i++, x += 1.f) {

            hi = i + fixed / 2;
            lo = hi - fixed;
            if (hi >= n) break;

            tN = N[hi] - N[lo];
            tX = X[hi] - X[lo];
            tXX = XX[hi] - XX[lo];
            tY = Y[hi] - Y[lo];
            tXY = XY[hi] - XY[lo];

            A = tY * tXX - tX * tXY;
            B = tN * tXY - tX * tY;
            D = tN * tXX - tX * tX;
            R = (A + x * B) / D;

            if (R - offset < noise[i]) noise[i] = R - offset;
        }
        for (; i < n; i++, x += 1.f) {
            R = (A + x * B) / D;
            if (R - offset < noise[i]) noise[i] = R - offset;
        }
    }

    /** octave/(8*eighth_octave_lines) x scale and dB y scale */
    static void seed_curve(float[] seed,
                           float[][] curves,
                           float amp,
                           int oc, int n,
                           int linesper, float dBoffset) {
        int i, post1;
        int seedptr;
        float[] posts;
        float[] curve;

        int choice = (int) ((amp + dBoffset - P_LEVEL_0) * .1f);
        choice = Math.max(choice, 0);
        choice = Math.min(choice, P_LEVELS - 1);
        posts = curves[choice];
//curve=posts+2;
//curve=new float[posts.length-2];
//System.arraycopy(posts,2,curve,0,curve.length);
        post1 = (int) posts[1];
        seedptr = (int) (oc + (posts[0] - EHMER_OFFSET) * linesper - (linesper >> 1));

        for (i = (int) posts[0]; i < post1; i++) {
            if (seedptr > 0) {
                float lin = amp + posts[i + 2];
                if (seed[seedptr] < lin) seed[seedptr] = lin;
            }
            seedptr += linesper;
            if (seedptr >= n) break;
        }
    }

    void seed_loop(float[][][] curves,
                   float[] f,
                   float[] flr,
                   float[] seed,
                   float specmax) {
        PsyInfo vi = this.vi;
        int n = this.n, i;
        float dBoffset = vi.max_curve_dB - specmax;

        // prime the working vector with peak values

        for (i = 0; i < n; i++) {
            float max = f[i];
            int oc = this.octave[i];
            while (i + 1 < n && this.octave[i + 1] == oc) {
                i++;
                if (f[i] > max) max = f[i];
            }

            if (max + 6.f > flr[i]) {
                oc = oc >> this.shiftoc;

                if (oc >= P_BANDS) oc = P_BANDS - 1;
                if (oc < 0) oc = 0;

                seed_curve(seed,
                        curves[oc],
                        max,
                        this.octave[i] - this.firstoc,
                        this.total_octave_lines,
                        this.eighth_octave_lines,
                        dBoffset);
            }
        }
    }

    private static void seedChase(float[] seeds, int linesper, int n) {

        int[] posstack = new int[n];
        float[] ampstack = new float[n];
        int stack = 0;
        int pos = 0;
        int i;

        for (i = 0; i < n; i++) {
            if (stack < 2) {
                posstack[stack] = i;
                ampstack[stack++] = seeds[i];
            } else {
                while (true) {
                    if (seeds[i] < ampstack[stack - 1]) {
                        posstack[stack] = i;
                        ampstack[stack++] = seeds[i];
                        break;
                    } else {
                        if (i < posstack[stack - 1] + linesper) {
                            if (stack > 1 && ampstack[stack - 1] <= ampstack[stack - 2] &&
                                    i < posstack[stack - 2] + linesper) {
                                // we completely overlap, making stack-1 irrelevant.  pop it
                                stack--;
                                continue;
                            }
                        }
                        posstack[stack] = i;
                        ampstack[stack++] = seeds[i];
                        break;

                    }
                }
            }
        }

        // the stack now contains only the positions that are relevant. Scan
        // 'em straight through

        for (i = 0; i < stack; i++) {
            long endpos;
            if (i < stack - 1 && ampstack[i + 1] > ampstack[i]) {
                endpos = posstack[i + 1];
            } else {
                // +1 is important, else bin 0 is
                // discarded in short frames
                endpos = posstack[i] + linesper + 1;
            }
            if (endpos > n) endpos = n;
            for (; pos < endpos; pos++)
                seeds[pos] = ampstack[i];
        }

        // there.  Linear time.  I now remember this was on a problem set I
        // had in Grad Skool... I didn't solve it at the time ;-)
    }

    public void psyInit(PsyInfo vi, InfoPsyGlobal gi, int n, int rate) {
        int i, j, lo = -99, hi = 1;
        int maxoc;

        this.eighth_octave_lines = gi.eighth_octave_lines;
        this.shiftoc = (int) Math.rint(Math.log(gi.eighth_octave_lines * 8.f) / Math.log(2.f)) - 1;

        this.firstoc = (int) (toOC(.25f * rate * .5f / n) * (1 << (this.shiftoc + 1)) - gi.eighth_octave_lines);
        maxoc = (int) (toOC((n + .25f) * rate * .5f / n) * (1 << (this.shiftoc + 1)) + .5f);
        this.total_octave_lines = maxoc - this.firstoc + 1;
        this.ath = new float[n]; //ogg_malloc(n*sizeof(*this.ath));

        this.octave = new int[n]; //_ogg_malloc(n*sizeof(*this.octave));
        this.bark = new int[n]; //_ogg_malloc(n*sizeof(*this.bark));
        this.vi = vi;
        this.n = n;
        this.rate = rate;

        // AoTuV HF weighting
        this.m_val = 1.f;
        if (rate < 26000) this.m_val = 0;
        else if (rate < 38000) this.m_val = .94f;   // 32kHz
        else if (rate > 46000) this.m_val = 1.275f; // 48kHz

        // ser up constans table use in sort
        if (this.index == null) {
            this.index = new int[1024];
            for (i = 0; i < 1024; i++) this.index[i] = i;
        }

        // set up the lookups for a given blocksize and sample rate

        for (i = 0, j = 0; i < MAX_ATH - 1; i++) {
            int endpos = (int) Math.rint(fromOC((i + 1) * .125f - 2.f) * 2 * n / rate);
            float base = ATH[i];
            if (j < endpos) {
                float delta = (ATH[i + 1] - base) / (endpos - j);
                for (; j < endpos && j < n; j++) {
                    this.ath[j] = base + 100.f;
                    base += delta;
                }
            }
        }

        for (i = 0; i < n; i++) {
            float bark = toBARK(rate / (2f * n) * i);

            for (; lo + vi.noisewindowlomin < i && toBARK(rate / (2f * n) * lo) < (bark - vi.noisewindowlo); lo++)
                ;
            for (; hi <= n && (hi < i + vi.noisewindowhimin || toBARK(rate / (2f * n) * hi) < (bark + vi.noisewindowhi)); hi++)
                ;

            this.bark[i] = ((lo - 1) << 16) + (hi - 1);
        }

        for (i = 0; i < n; i++)
            this.octave[i] = (int) (toOC((i + .25f) * .5f * rate / n) * (1 << (this.shiftoc + 1)) + .5f);

        this.tonecurves = setupToneCurves(vi.toneatt, rate * .5f / n, n,
                vi.tone_centerboost, vi.tone_decay);

        // set up rolling noise median
        this.noiseoffset = new float[P_NOISECURVES][];
        for (i = 0; i < P_NOISECURVES; i++) {
            this.noiseoffset[i] = new float[n];
        }

        for (i = 0; i < n; i++) {
            float halfoc = toOC((i + .5f) * rate / (2.f * n)) * 2.f;

            if (halfoc < 0) halfoc = 0;
            if (halfoc >= P_BANDS - 1) halfoc = P_BANDS - 1;
            int inthalfoc = (int) halfoc;
            float del = halfoc - inthalfoc;

            for (j = 0; j < P_NOISECURVES; j++) {
                int inthalfocx = ((inthalfoc + 1) >= this.vi.noiseoff[j].length) ? this.vi.noiseoff[j].length - 1 : inthalfoc + 1;
                this.noiseoffset[j][i] =
                        this.vi.noiseoff[j][inthalfoc] * (1.f - del) +
                                this.vi.noiseoff[j][inthalfocx] * del;
            }
        }
    }

    private static void minCurve(float[] c, float[] c2) {
        for (int i = 0; i < EHMER_MAX; i++) if (c2[i] < c[i]) c[i] = c2[i];
    }

    private static void maxCurve(float[] c, float[] c2) {
        for (int i = 0; i < EHMER_MAX; i++) if (c2[i] > c[i]) c[i] = c2[i];
    }

    private static void attenuateCurve(float[] c, float att) {
        for (int i = 0; i < EHMER_MAX; i++)
            c[i] += att;
    }

    private static float[][][] setupToneCurves(float[] curveatt_dB, float binHz, int n,
                                               float center_boost, float center_decay_rate) {
        int i, j, k, m;
        float[] ath = new float[EHMER_MAX];
        float[][][] workc = new float[P_BANDS][P_LEVELS][EHMER_MAX];
        float[][] athc = new float[P_LEVELS][EHMER_MAX];
        float[] brute_buffer = new float[n];

        float[][][] ret = new float[P_BANDS][][];

        for (i = 0; i < P_BANDS; i++) {
            // we add back in the ATH to avoid low level curves falling off to
            // -infinity and unnecessarily cutting off high level curves in the
            // curve limiting (last step).

            // A half-band's settings must be valid over the whole band, and
            // it's better to mask too little than too much
            int ath_offset = i * 4;
            for (j = 0; j < EHMER_MAX; j++) {
                float min = 999.f;
                for (k = 0; k < 4; k++)
                    if (j + k + ath_offset < MAX_ATH) {
                        if (min > ATH[j + k + ath_offset]) min = ATH[j + k + ath_offset];
                    } else {
                        if (min > ATH[MAX_ATH - 1]) min = ATH[MAX_ATH - 1];
                    }
                ath[j] = min;
            }

            // copy curves into working space, replicate the 50dB curve to 30
            // and 40, replicate the 100dB curve to 110
            for (j = 0; j < 6; j++) {
                System.arraycopy(tonemasks[i][j], 0, workc[i][j + 2], 0, EHMER_MAX);
            }
            System.arraycopy(tonemasks[i][0], 0, workc[i][0], 0, EHMER_MAX);
            System.arraycopy(tonemasks[i][0], 0, workc[i][1], 0, EHMER_MAX);

            // apply centered curve boost/decay
            for (j = 0; j < P_LEVELS; j++) {
                for (k = 0; k < EHMER_MAX; k++) {
                    float adj = center_boost + Math.abs(EHMER_OFFSET - k) * center_decay_rate;
                    if (adj < 0. && center_boost > 0) adj = 0.f;
                    if (adj > 0. && center_boost < 0) adj = 0.f;
                    workc[i][j][k] += adj;
                }
            }

            // normalize curves so the driving amplitude is 0dB
            // make temp curves with the ATH overlayed
            for (j = 0; j < P_LEVELS; j++) {
                attenuateCurve(workc[i][j], curveatt_dB[i] + 100.f - (j < 2 ? 2 : j) * 10.f - P_LEVEL_0);
                System.arraycopy(ath, 0, athc[j], 0, EHMER_MAX);
                attenuateCurve(athc[j], +100.f - j * 10.f - P_LEVEL_0);
                maxCurve(athc[j], workc[i][j]);
            }

            // Now limit the louder curves.
            //
            // the idea is this: We don't know what the playback attenuation
            // will be; 0dB SL moves every time the user twiddles the volume
            // knob. So that means we have to use a single 'most pessimal' curve
            // for all masking amplitudes, right?  Wrong.  The *loudest* sound
            // can be in (we assume) a range of ...+100dB] SL.  However, sounds
            // 20dB down will be in a range ...+80], 40dB down is from ...+60],
            // etc...

            for (j = 1; j < P_LEVELS; j++) {
                minCurve(athc[j], athc[j - 1]);
                minCurve(workc[i][j], athc[j]);
            }
        }

        for (i = 0; i < P_BANDS; i++) {
            int hi_curve, lo_curve, bin;
            ret[i] = new float[P_LEVELS][];

            // low frequency curves are measured with greater resolution than
            // the MDCT/FFT will actually give us; we want the curve applied
            // to the tone data to be pessimistic and thus apply the minimum
            // masking possible for a given bin.  That means that a single bin
            // could span more than one octave and that the curve will be a
            // composite of multiple octaves.  It also may mean that a single
            // bin may span > an eighth of an octave and that the eighth
            // octave values may also be composited.

            // which octave curves will we be compositing?
            bin = (int) Math.floor(fromOC(i * .5f) / binHz);
            lo_curve = (int) Math.ceil((double) toOC(bin * binHz + 1) * 2);
            hi_curve = (int) Math.floor(toOC((bin + 1) * binHz) * 2);
            if (lo_curve > i) lo_curve = i;
            if (lo_curve < 0) lo_curve = 0;
            if (hi_curve >= P_BANDS) hi_curve = P_BANDS - 1;

            for (m = 0; m < P_LEVELS; m++) {
                ret[i][m] = new float[EHMER_MAX + 2];

                for (j = 0; j < n; j++) brute_buffer[j] = 999.f;

                // render the curve into bins, then pull values back into curve.
                // The point is that any inherent subsampling aliasing results in
                // a safe minimum
                for (k = lo_curve; k <= hi_curve; k++) {
                    int l = 0;

                    for (j = 0; j < EHMER_MAX; j++) {
                        int lo_bin = (int) (fromOC(j * .125f + k * .5f - 2.0625f) / binHz);
                        int hi_bin = (int) (fromOC(j * .125f + k * .5f - 1.9375f) / binHz + 1);

                        if (lo_bin < 0) lo_bin = 0;
                        if (lo_bin > n) lo_bin = n;
                        if (lo_bin < l) l = lo_bin;
                        if (hi_bin < 0) hi_bin = 0;
                        if (hi_bin > n) hi_bin = n;

                        for (; l < hi_bin && l < n; l++)
                            if (brute_buffer[l] > workc[k][m][j])
                                brute_buffer[l] = workc[k][m][j];
                    }

                    for (; l < n; l++)
                        if (brute_buffer[l] > workc[k][m][EHMER_MAX - 1])
                            brute_buffer[l] = workc[k][m][EHMER_MAX - 1];
                }

                // be equally paranoid about being valid up to next half ocatve
                if (i + 1 < P_BANDS) {
                    int l = 0;
                    k = i + 1;
                    for (j = 0; j < EHMER_MAX; j++) {
                        int lo_bin = (int) (fromOC(j * .125f + i * .5f - 2.0625f) / binHz);
                        int hi_bin = (int) (fromOC(j * .125f + i * .5f - 1.9375f) / binHz + 1);

                        if (lo_bin < 0) lo_bin = 0;
                        if (lo_bin > n) lo_bin = n;
                        if (lo_bin < l) l = lo_bin;
                        if (hi_bin < 0) hi_bin = 0;
                        if (hi_bin > n) hi_bin = n;

                        for (; l < hi_bin && l < n; l++)
                            if (brute_buffer[l] > workc[k][m][j])
                                brute_buffer[l] = workc[k][m][j];
                    }

                    for (; l < n; l++)
                        if (brute_buffer[l] > workc[k][m][EHMER_MAX - 1])
                            brute_buffer[l] = workc[k][m][EHMER_MAX - 1];
                }

                for (j = 0; j < EHMER_MAX; j++) {
                    bin = (int) (fromOC(j * .125f + i * .5f - 2.f) / binHz);
                    if (bin < 0) {
                        ret[i][m][j + 2] = -999.f;
                    } else {
                        if (bin >= n) {
                            ret[i][m][j + 2] = -999.f;
                        } else {
                            ret[i][m][j + 2] = brute_buffer[bin];
                        }
                    }
                }

                // add fenceposts
                for (j = 0; j < EHMER_OFFSET; j++)
                    if (ret[i][m][j + 2] > -200.f) break;
                ret[i][m][0] = j;

                for (j = EHMER_MAX - 1; j > EHMER_OFFSET + 1; j--)
                    if (ret[i][m][j + 2] > -200.f)
                        break;
                ret[i][m][1] = j;
            }
        }

        return ret;
    }

    private static float toBARK(float n) {
        return (float) (13.1f * Math.atan(.00074f * (n)) + 2.24f * Math.atan((n) * (n) * 1.85e-8f) +
                1e-4f * (n));
    }

    private static float fromBARK(float z) {
        return (float) (102.f * (z) - 2.f * Math.pow(z, 2.f) + .4f * Math.pow(z, 3.f) + Math.pow(1.46f, z) -
                1.f);
    }

    private static float toMEL(float n) {
        return (float) (Math.log(1.f + (n) * .001f) * 1442.695f);
    }

    private static float fromMEL(float m) {
        return (float) (1000.f * Math.exp((m) / 1442.695f) - 1000.f);
    }

    /**
     * Frequency to octave.  We arbitrarily declare 63.5 Hz to be octave
     * 0.0
     */
    private static float toOC(float n) {
        return (float) (Math.log(n) * 1.442695f - 5.965784f);
    }

    private static float fromOC(float o) {
        return (float) (Math.exp(((o) + 5.965784f) * .693147f));
    }

    void init(PsyInfo vi, int n, int rate) {

//        float rate2 = rate / 2.;
//        //memset(p,0,sizeof(vorbis_look_psy));
//        ath = new float[n];
//        octave = new int[n];
//        this.vi = vi;
//        this.n = n;
//
//        // set up the lookups for a given blocksize and sample rate
//        // Vorbis max sample rate is limited by 26 Bark (54kHz)
//        set_curve(ATH_Bark_dB, ath, n, rate);
//        for (int i = 0; i < n; i++)
//            ath[i] = fromdB(ath[i] + vi.ath_att);
//
//        for (int i = 0; i < n; i++) {
//            int oc = rint(toOC((i + .5) * rate2 / n) * 2.);
//            if (oc < 0) oc = 0;
//            if (oc > 12) oc = 12;
//            octave[i] = oc;
//        }
//
//        tonecurves = malloc(13 * sizeof( float **));
//        noisecurves = malloc(13 * sizeof( float **));
//        peakatt = malloc(7 * sizeof( float *));
//        for (int i = 0; i < 13; i++) {
//            tonecurves[i] = malloc(9 * sizeof( float *));
//            noisecurves[i] = malloc(9 * sizeof( float *));
//        }
//        for (i = 0; i < 7; i++)
//            peakatt[i] = malloc(5 * sizeof( float));
//
//        for (i = 0; i < 13; i++) {
//            for (j = 0; j < 9; j++) {
//                tonecurves[i][j] = malloc(EHMER_MAX * sizeof( float));
//                noisecurves[i][j] = malloc(EHMER_MAX * sizeof( float));
//            }
//        }
//
//        // OK, yeah, this was a silly way to do it
//        memcpy(tonecurves[0][2], tone_125_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[0][4], tone_125_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[0][6], tone_125_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[0][8], tone_125_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[2][2], tone_250_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[2][4], tone_250_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[2][6], tone_250_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[2][8], tone_250_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[4][2], tone_500_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[4][4], tone_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[4][6], tone_500_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[4][8], tone_500_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[6][2], tone_1000_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[6][4], tone_1000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[6][6], tone_1000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[6][8], tone_1000_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[8][2], tone_2000_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[8][4], tone_2000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[8][6], tone_2000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[8][8], tone_2000_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[10][2], tone_4000_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[10][4], tone_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[10][6], tone_4000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[10][8], tone_4000_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(tonecurves[12][2], tone_4000_40dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[12][4], tone_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[12][6], tone_8000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(tonecurves[12][8], tone_8000_100dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[0][2], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[0][4], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[0][6], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[0][8], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[2][2], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[2][4], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[2][6], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[2][8], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[4][2], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[4][4], noise_500_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[4][6], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[4][8], noise_500_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[6][2], noise_1000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[6][4], noise_1000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[6][6], noise_1000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[6][8], noise_1000_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[8][2], noise_2000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[8][4], noise_2000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[8][6], noise_2000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[8][8], noise_2000_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[10][2], noise_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[10][4], noise_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[10][6], noise_4000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[10][8], noise_4000_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        memcpy(noisecurves[12][2], noise_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[12][4], noise_4000_60dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[12][6], noise_4000_80dB_SL, sizeof( float)*EHMER_MAX);
//        memcpy(noisecurves[12][8], noise_4000_80dB_SL, sizeof( float)*EHMER_MAX);
//
//        setup_curve(tonecurves[0], 0, vi.toneatt_125Hz);
//        setup_curve(tonecurves[2], 2, vi.toneatt_250Hz);
//        setup_curve(tonecurves[4], 4, vi.toneatt_500Hz);
//        setup_curve(tonecurves[6], 6, vi.toneatt_1000Hz);
//        setup_curve(tonecurves[8], 8, vi.toneatt_2000Hz);
//        setup_curve(tonecurves[10], 10, vi.toneatt_4000Hz);
//        setup_curve(tonecurves[12], 12, vi.toneatt_8000Hz);
//
//        setup_curve(noisecurves[0], 0, vi.noiseatt_125Hz);
//        setup_curve(noisecurves[2], 2, vi.noiseatt_250Hz);
//        setup_curve(noisecurves[4], 4, vi.noiseatt_500Hz);
//        setup_curve(noisecurves[6], 6, vi.noiseatt_1000Hz);
//        setup_curve(noisecurves[8], 8, vi.noiseatt_2000Hz);
//        setup_curve(noisecurves[10], 10, vi.noiseatt_4000Hz);
//        setup_curve(noisecurves[12], 12, vi.noiseatt_8000Hz);
//
//        for (i = 1; i < 13; i += 2) {
//            for (j = 0; j < 9; j++) {
//                interp_curve_dB(tonecurves[i][j],
//                        tonecurves[i - 1][j],
//                        tonecurves[i + 1][j], .5);
//                interp_curve_dB(noisecurves[i][j],
//                        noisecurves[i - 1][j],
//                        noisecurves[i + 1][j], .5);
//            }
//        }
//        for (i = 0; i < 5; i++) {
//            peakatt[0][i] = fromdB(vi.peakatt_125Hz[i]);
//            peakatt[1][i] = fromdB(vi.peakatt_250Hz[i]);
//            peakatt[2][i] = fromdB(vi.peakatt_500Hz[i]);
//            peakatt[3][i] = fromdB(vi.peakatt_1000Hz[i]);
//            peakatt[4][i] = fromdB(vi.peakatt_2000Hz[i]);
//            peakatt[5][i] = fromdB(vi.peakatt_4000Hz[i]);
//            peakatt[6][i] = fromdB(vi.peakatt_8000Hz[i]);
//        }
    }

    static float[] FLOOR1_fromdB_INV_LOOKUP = {
            0.F, 8.81683e+06F, 8.27882e+06F, 7.77365e+06F,
            7.29930e+06F, 6.85389e+06F, 6.43567e+06F, 6.04296e+06F,
            5.67422e+06F, 5.32798e+06F, 5.00286e+06F, 4.69759e+06F,
            4.41094e+06F, 4.14178e+06F, 3.88905e+06F, 3.65174e+06F,
            3.42891e+06F, 3.21968e+06F, 3.02321e+06F, 2.83873e+06F,
            2.66551e+06F, 2.50286e+06F, 2.35014e+06F, 2.20673e+06F,
            2.07208e+06F, 1.94564e+06F, 1.82692e+06F, 1.71544e+06F,
            1.61076e+06F, 1.51247e+06F, 1.42018e+06F, 1.33352e+06F,
            1.25215e+06F, 1.17574e+06F, 1.10400e+06F, 1.03663e+06F,
            973377.F, 913981.F, 858210.F, 805842.F,
            756669.F, 710497.F, 667142.F, 626433.F,
            588208.F, 552316.F, 518613.F, 486967.F,
            457252.F, 429351.F, 403152.F, 378551.F,
            355452.F, 333762.F, 313396.F, 294273.F,
            276316.F, 259455.F, 243623.F, 228757.F,
            214798.F, 201691.F, 189384.F, 177828.F,
            166977.F, 156788.F, 147221.F, 138237.F,
            129802.F, 121881.F, 114444.F, 107461.F,
            100903.F, 94746.3F, 88964.9F, 83536.2F,
            78438.8F, 73652.5F, 69158.2F, 64938.1F,
            60975.6F, 57254.9F, 53761.2F, 50480.6F,
            47400.3F, 44507.9F, 41792.0F, 39241.9F,
            36847.3F, 34598.9F, 32487.7F, 30505.3F,
            28643.8F, 26896.0F, 25254.8F, 23713.7F,
            22266.7F, 20908.0F, 19632.2F, 18434.2F,
            17309.4F, 16253.1F, 15261.4F, 14330.1F,
            13455.7F, 12634.6F, 11863.7F, 11139.7F,
            10460.0F, 9821.72F, 9222.39F, 8659.64F,
            8131.23F, 7635.06F, 7169.17F, 6731.70F,
            6320.93F, 5935.23F, 5573.06F, 5232.99F,
            4913.67F, 4613.84F, 4332.30F, 4067.94F,
            3819.72F, 3586.64F, 3367.78F, 3162.28F,
            2969.31F, 2788.13F, 2617.99F, 2458.24F,
            2308.24F, 2167.39F, 2035.14F, 1910.95F,
            1794.35F, 1684.85F, 1582.04F, 1485.51F,
            1394.86F, 1309.75F, 1229.83F, 1154.78F,
            1084.32F, 1018.15F, 956.024F, 897.687F,
            842.910F, 791.475F, 743.179F, 697.830F,
            655.249F, 615.265F, 577.722F, 542.469F,
            509.367F, 478.286F, 449.101F, 421.696F,
            395.964F, 371.803F, 349.115F, 327.812F,
            307.809F, 289.026F, 271.390F, 254.830F,
            239.280F, 224.679F, 210.969F, 198.096F,
            186.008F, 174.658F, 164.000F, 153.993F,
            144.596F, 135.773F, 127.488F, 119.708F,
            112.404F, 105.545F, 99.1046F, 93.0572F,
            87.3788F, 82.0469F, 77.0404F, 72.3394F,
            67.9252F, 63.7804F, 59.8885F, 56.2341F,
            52.8027F, 49.5807F, 46.5553F, 43.7144F,
            41.0470F, 38.5423F, 36.1904F, 33.9821F,
            31.9085F, 29.9614F, 28.1332F, 26.4165F,
            24.8045F, 23.2910F, 21.8697F, 20.5352F,
            19.2822F, 18.1056F, 17.0008F, 15.9634F,
            14.9893F, 14.0746F, 13.2158F, 12.4094F,
            11.6522F, 10.9411F, 10.2735F, 9.64662F,
            9.05798F, 8.50526F, 7.98626F, 7.49894F,
            7.04135F, 6.61169F, 6.20824F, 5.82941F,
            5.47370F, 5.13970F, 4.82607F, 4.53158F,
            4.25507F, 3.99542F, 3.75162F, 3.52269F,
            3.30774F, 3.10590F, 2.91638F, 2.73842F,
            2.57132F, 2.41442F, 2.26709F, 2.12875F,
            1.99885F, 1.87688F, 1.76236F, 1.65482F,
            1.55384F, 1.45902F, 1.36999F, 1.28640F,
            1.20790F, 1.13419F, 1.06499F, 1.F
    };

    public int[] noisenNormalizeSort(float[] magnitudes) {
        int i, j, m, k, w, n = this.n;
        PsyInfo vi = this.vi;
        int partition = vi.normal_partition;
        int start = vi.normal_start;

        if (start > n) return new int[magnitudes.length];
        float[] workx = new float[magnitudes.length];

        for (k = start; k < workx.length; k++) workx[k] = Math.abs(magnitudes[k]);

        return sort(workx, start, n, partition);
    }

    public int[][] quantizeCoupleSort(InfoMapping0 vi,
                                      float[][] mags) {

        if (this.vi.normal_point_p != 0) {
            int i, j, k, m, w, n = this.n;
            int[][] ret = new int[vi.coupling_steps][n];
            int partition = this.vi.normal_partition;
            float[][] work = new float[vi.coupling_steps][n];

            for (i = 0; i < vi.coupling_steps; i++) {
                for (k = 0; k < n; k++) work[i][k] = Math.abs(mags[i][k]);

                ret[i] = sort(work[i], 0, n, partition);
            }

            return ret;
        }
        return null;
    }

    private int[] sort(float[] tab, int start, int end, int partition) {
        int[] wyn = new int[end];
        System.arraycopy(index, 0, wyn, 0, wyn.length);

        for (int i = start; i < end; i += partition) {
            if (i + partition > end) partition = end - i;
            quicksort(tab, i, i + partition - 1, wyn);
        }
        if (start > 0)
            System.arraycopy(wyn, start, wyn, 0, wyn.length - start);

        return wyn;
    }

    private static void quicksort(float[] tablica, int x, int y, int[] index) {
        int i, j, n, m, ntemp;
        float v, temp;
        i = x;
        j = y;
        v = tablica[(x + y) / 2];

        do {
            while (tablica[i] > v)
                i++;
            while (v > tablica[j])
                j--;
            if (i <= j) {
                temp = tablica[i];
                tablica[i] = tablica[j];
                tablica[j] = temp;
                ntemp = index[i];
                index[i] = index[j];
                index[j] = ntemp;
                i++;
                j--;
            }
        } while (i <= j);

        if (x < j)
            quicksort(tablica, x, j, index);
        if (i < y)
            quicksort(tablica, i, y, index);
    }

    /**
     * doing the real circular magnitude calculation is audibly superior
     * to (A+B)/sqrt(2)
     */
    private static float dipoleHypot(float a, float b) {
        if (a > 0.) {
            if (b > 0.) return (float) Math.sqrt(a * a + b * b);
            if (a > -b) return (float) Math.sqrt(a * a - b * b);
            return -(float) Math.sqrt(b * b - a * a);
        }
        if (b < 0.) return -(float) Math.sqrt(a * a + b * b);
        if (-a > b) return -(float) Math.sqrt(a * a - b * b);
        return (float) Math.sqrt(b * b - a * a);
    }

    private static float roundHypot(float a, float b) {
        if (a > 0.) {
            if (b > 0.) return (float) Math.sqrt(a * a + b * b);
            if (a > -b) return (float) Math.sqrt(a * a + b * b);
            return -(float) Math.sqrt(b * b + a * a);
        }
        if (b < 0.) return -(float) Math.sqrt(a * a + b * b);
        if (-a > b) return -(float) Math.sqrt(a * a + b * b);
        return (float) Math.sqrt(b * b + a * a);
    }

    /** revert to round hypot for now */
    public float[][] quantizeCoupleMemo(InfoPsyGlobal g,
                                        InfoMapping0 vi,
                                        float[][] mdct) {

        int i, j, n = this.n;
        float[][] ret = new float[vi.coupling_steps][];
        int limit = g.coupling_pointlimit[this.vi.blockflag][Const.PACKETBLOBS / 2];

        for (i = 0; i < vi.coupling_steps; i++) {
            float[] mdctM = mdct[vi.coupling_mag[i]];
            float[] mdctA = mdct[vi.coupling_ang[i]];
            ret[i] = new float[n];
            for (j = 0; j < limit; j++)
                ret[i][j] = dipoleHypot(mdctM[j], mdctA[j]);
            for (; j < n; j++)
                ret[i][j] = roundHypot(mdctM[j], mdctA[j]);
        }

        return ret;
    }

    // AoTuV

    /**
     * @ M2 **
     * The boost problem by the combination of noise normalization and point stereo is eased.
     * However, this is a temporary patch.
     * by Aoyumi @ 2004/04/18
     */
    public void hfReduction(InfoPsyGlobal g,
                            InfoMapping0 vi,
                            float[][] mdct) {

        int i, j, n = this.n, de = (int) (0.3 * this.m_val);
        int limit = g.coupling_pointlimit[this.vi.blockflag][Const.PACKETBLOBS / 2];
        int start = this.vi.normal_start;

        for (i = 0; i < vi.coupling_steps; i++) {
// for(j=start; j<limit; j++){} // ???
            for (j = limit; j < n; j++)
                mdct[i][j] = (float) (mdct[i][j] * (1.0 - de * ((float) (j - limit) / (float) (n - limit))));
        }
    }

    private static float unitNorm(float x) {
        int ix = Float.floatToIntBits(x);
        ix = (ix & 0x80000000) | (0x3f800000);
        return Float.intBitsToFloat(ix);
    }

    public void noiseNormalize(float[] in,
                               float[] out,
                               int pout,
                               int[] sortedindex) {
        int flag = 0, i, j = 0, n = this.n;
        PsyInfo vi = this.vi;
        int partition = vi.normal_partition;
        int start = vi.normal_start;

        if (start > n) start = n;

        if (vi.normal_channel_p != 0) {
            for (; j < start; j++)
                out[j + pout] = (float) Math.rint(in[j]);

            for (; j + partition <= n; j += partition) {
                float acc = 0.f;
                int k;

                for (i = j; i < j + partition; i++)
                    acc += in[i] * in[i];

                for (i = 0; i < partition; i++) {
                    k = sortedindex[i + j - start];

                    if (in[k] * in[k] >= .25f) {
                        out[k + pout] = (float) Math.rint(in[k]);
                        acc -= in[k] * in[k];
                        flag = 1;
                    } else {
                        if (acc < vi.normal_thresh) break;
                        out[k + pout] = unitNorm(in[k]);
                        acc = (float) (acc - 1.);
                    }
                }

                for (; i < partition; i++) {
                    k = sortedindex[i + j - start];
                    out[k + pout] = 0.f;
                }
            }
        }

        for (; j < n; j++)
            out[j + pout] = (float) Math.rint(in[j]);

    }

    void removeFloor(float[] mdct,
                     int[] codedflr,
                     float[] residue,
                     int sliding_lowpass) {

        int i, n = this.n;

        if (sliding_lowpass > n) sliding_lowpass = n;

        for (i = 0; i < sliding_lowpass; i++) {
            residue[i] =
                    mdct[i] * FLOOR1_fromdB_INV_LOOKUP[codedflr[i]];
        }

        for (; i < n; i++)
            residue[i] = 0.f;
    }

    void offsetAndMix(float[] noise,
                      float[] tone,
                      int offset_select,
                      float[] logmask,
                      float[] mdct,
                      float[] logmdct,
                      int plogmdct) {
        int i, n = this.n;
        float de, coeffi, cx; // AoTuV
        float toneatt = this.vi.tone_masteratt[offset_select];

        cx = this.m_val;

        for (i = 0; i < n; i++) {
            float val = noise[i] + this.noiseoffset[offset_select][i];
            if (val > this.vi.noisemaxsupp) val = this.vi.noisemaxsupp;
            logmask[i] = Math.max(val, tone[i] + toneatt);

            // AoTuV
            // @ M1
            // The following codes improve a noise problem.
            // A fundamental idea uses the value of masking and carries out
            // the relative compensation of the MDCT.
            // However, this code is not perfect and all noise problems cannot be solved.
            // by Aoyumi @ 2004/04/18

            if (offset_select == 1) {
                coeffi = -17.2f; // coeffi is a -17.2dB threshold
                val = val - logmdct[i + plogmdct]; // val == mdct line value relative to floor in dB

                if (val > coeffi) {
                    // mdct value is > -17.2 dB below floor

                    de = 1.0f - ((val - coeffi) * 0.005f * cx);
                    // pro-rated attenuation:
                    // -0.00 dB boost if mdct value is -17.2dB (relative to floor)
                    // -0.77 dB boost if mdct value is 0dB (relative to floor)
                    // -1.64 dB boost if mdct value is +17.2dB (relative to floor)
                    // etc...

                    if (de < 0) de = 0.0001f;
                } else
                    // mdct value is <= -17.2 dB below floor
                    de = 1.0f - ((val - coeffi) * 0.0003f * cx);

                // pro-rated attenuation:
                // +0.00 dB atten if mdct value is -17.2dB (relative to floor)
                // +0.45 dB atten if mdct value is -34.4dB (relative to floor)
                // etc...

                mdct[i] *= de;
            }
        }
    }

    static float[] STEREO_THRESHHOLDS = {0.0f, .5f, 1.0f, 1.5f, 2.5f, 4.5f, 8.5f, 16.5f, 9e10f};
    static float[] STEREO_THRESHHOLDS_LIMITED = {0.0f, .5f, 1.0f, 1.5f, 2.0f, 2.5f, 4.5f, 8.5f, 9e10f};

    public void couple(int blobno,
                       InfoPsyGlobal g,
                       InfoMapping0 vi,
                       float[][] res,
                       float[][] mag_memo,
                       int[][] mag_sort,
                       int[][] ifloor,
                       int[] nonzero,
                       int sliding_lowpass) {

        int i, j, k, n = this.n;
        Parax para = new Parax();

        // perform any requested channel coupling
        // point stereo can only be used in a first stage (in this encoder)
        // because of the dependency on floor lookups
        for (i = 0; i < vi.coupling_steps; i++) {

            // once we're doing multistage coupling in which a channel goes
            // through more than one coupling step, the floor vector
            // magnitudes will also have to be recalculated a propagated
            // along with PCM.  Right now, we're not (that will wait until 5.1
            // most likely), so the code isn't here yet. The memory management
            // here is all assuming single depth couplings anyway.

            // make sure coupling a zero and a nonzero channel results in two
            // nonzero channels.
            if ((nonzero[vi.coupling_mag[i]] != 0) ||
                    (nonzero[vi.coupling_ang[i]] != 0)) {

                float[] rM = res[vi.coupling_mag[i]];
                float[] rA = res[vi.coupling_ang[i]];
                int[] floorM = ifloor[vi.coupling_mag[i]];
                int[] floorA = ifloor[vi.coupling_ang[i]];
                float prepoint = STEREO_THRESHHOLDS[g.coupling_prepointamp[blobno]];
                float postpoint = STEREO_THRESHHOLDS[g.coupling_postpointamp[blobno]];
                int partition = ((this.vi.normal_point_p != 0) ? this.vi.normal_partition : this.n);
                int limit = g.coupling_pointlimit[this.vi.blockflag][blobno];
                int pointlimit = limit;

                nonzero[vi.coupling_mag[i]] = 1;
                nonzero[vi.coupling_ang[i]] = 1;

                // The threshold of a stereo is changed with the size of n
                if (n > 1000)
                    postpoint = STEREO_THRESHHOLDS_LIMITED[g.coupling_postpointamp[blobno]];

                for (j = 0; j < this.n; j += partition) {
                    float acc = 0.f;

                    for (k = 0; k < partition; k++) {
                        int l = k + j;

                        if (l < sliding_lowpass) {
                            if ((l >= limit && Math.abs(rM[l]) < postpoint && Math.abs(rA[l]) < postpoint) ||
                                    (Math.abs(rM[l]) < prepoint && Math.abs(rA[l]) < prepoint)) {

                                rM[n + l] = precomputedCouplePoint(mag_memo[i][l],
                                        floorM[l], floorA[l],
                                        rM[n + l]);
                                rA[n + l] = 0.0f;

                                if (Math.rint(rM[l + n]) == 0.) acc += rM[l + n] * rM[l + n];
                            } else {
                                para.setMagAng(rM[l + n], rA[l + n]);
                                coupleLossless(rM[l], rA[l], para);
                                rM[l + n] = para.A;
                                rA[l + n] = para.B;
                            }
                        } else {
                            rM[l + n] = 0.f;
                            rA[l + n] = 0.f;
                        }
                    }

                    if (this.vi.normal_point_p != 0) {
                        for (k = 0; k < partition && acc >= this.vi.normal_thresh; k++) {
                            int l = mag_sort[i][j + k];
                            if (l < sliding_lowpass && l >= pointlimit && Math.rint(rM[l + n]) == 0.f) {
                                rM[l + n] = unitNorm(rM[l + n]);
                                acc -= 1.f;
                            }
                        }
                    }
                }
            }
        }
    }

    static float[] HYPOT_LOOKUP = {
            -0.009935f, -0.011245f, -0.012726f, -0.014397f,
            -0.016282f, -0.018407f, -0.020800f, -0.023494f,
            -0.026522f, -0.029923f, -0.033737f, -0.038010f,
            -0.042787f, -0.048121f, -0.054064f, -0.060671f,
            -0.068000f, -0.076109f, -0.085054f, -0.094892f,
            -0.105675f, -0.117451f, -0.130260f, -0.144134f,
            -0.159093f, -0.175146f, -0.192286f, -0.210490f,
            -0.229718f, -0.249913f, -0.271001f, -0.292893f};

    private static float precomputedCouplePoint(float premag,
                                                int floorA, int floorB,
                                                float mag) {

        int test = (floorA > floorB) ? 0 : -1;
        int offset = 31 - Math.abs(floorA - floorB);
        float floormag = HYPOT_LOOKUP[(offset < 0) ? 0 : offset] + 1.f;

        floormag *= FLOOR1_fromdB_INV_LOOKUP[(floorB & test) | (floorA & (~test))];

        mag = premag * floormag;
        return mag;
    }

    private static void coupleLossless(float A, float B, Parax q) {
        int test1 = (Math.abs(q.A) > Math.abs(q.B)) ? 1 : 0;
        test1 -= (Math.abs(q.A) < Math.abs(q.B)) ? 1 : 0;
        if (test1 == 0) test1 = ((Math.abs(A) > Math.abs(B)) ? (1 << 1) - 1 : 0);
        if (test1 == 1) {
            q.B = (q.A > 0.f ? q.A - q.B : q.B - q.A);
        } else {
            float temp = q.B;
            q.B = (q.B > 0.f ? q.A - q.B : q.B - q.A);
            q.A = temp;
        }

        if (q.B > Math.abs(q.A) * 1.9999f) {
            q.B = -Math.abs(q.A) * 2.f;
            q.A = -q.A;
        }
    }
}
